//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g 2018-12-10 11:35:49

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


#pragma warning disable 3021
#pragma warning disable 0414


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class StateMachineTransitionParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ARGTYPE_DELEGATE", "ARGTYPE_FLOAT", "ARGTYPE_INT", "FLOAT", "ID", "INT", "LEFT_CBRACKET", "LEFT_PAREN", "NEWLINE", "NOT", "OR", "PROG", "PROGEXPR", "PROGEXPR_RESTART", "RIGHT_CBRACKET", "RIGHT_PAREN", "VARARGS", "VARDECL", "VARDECLBLOCK", "VARNAME", "VARTYPE", "WS", "XOR", "','", "';'"
	};
	public const int EOF=-1;
	public const int T__28=28;
	public const int T__29=29;
	public const int AND=4;
	public const int ARGTYPE_DELEGATE=5;
	public const int ARGTYPE_FLOAT=6;
	public const int ARGTYPE_INT=7;
	public const int FLOAT=8;
	public const int ID=9;
	public const int INT=10;
	public const int LEFT_CBRACKET=11;
	public const int LEFT_PAREN=12;
	public const int NEWLINE=13;
	public const int NOT=14;
	public const int OR=15;
	public const int PROG=16;
	public const int PROGEXPR=17;
	public const int PROGEXPR_RESTART=18;
	public const int RIGHT_CBRACKET=19;
	public const int RIGHT_PAREN=20;
	public const int VARARGS=21;
	public const int VARDECL=22;
	public const int VARDECLBLOCK=23;
	public const int VARNAME=24;
	public const int VARTYPE=25;
	public const int WS=26;
	public const int XOR=27;

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false, false, false, 
				false, false, false, false, false, false, false, false
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public StateMachineTransitionParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public StateMachineTransitionParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}
	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return StateMachineTransitionParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g"; } }


	public AstParserRuleReturnScope<CommonTree, IToken> process() {
		TreeAdaptor = new CommonTreeAdaptor();
		return prog();
	}


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_prog() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_prog() {}

	// $ANTLR start "prog"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:43:1: prog : ( declBlock )? ( ignore )* expr -> ^( PROG ( declBlock )? expr ) ;
	[GrammarRule("prog")]
	private AstParserRuleReturnScope<CommonTree, IToken> prog()
	{
		EnterRule_prog();
		EnterRule("prog", 1);
		TraceIn("prog", 1);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    AstParserRuleReturnScope<CommonTree, IToken> declBlock1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore2 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> expr3 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    RewriteRuleSubtreeStream stream_declBlock=new RewriteRuleSubtreeStream(adaptor,"rule declBlock");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "prog");
		DebugLocation(43, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:43:6: ( ( declBlock )? ( ignore )* expr -> ^( PROG ( declBlock )? expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:43:9: ( declBlock )? ( ignore )* expr
			{
			DebugLocation(43, 9);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:43:9: ( declBlock )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, decisionCanBacktrack[1]);
			int LA1_0 = input.LA(1);

			if ((LA1_0==LEFT_CBRACKET))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:43:10: declBlock
				{
				DebugLocation(43, 10);
				PushFollow(Follow._declBlock_in_prog120);
				declBlock1=declBlock();
				PopFollow();

				stream_declBlock.Add(declBlock1.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(43, 22);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:43:22: ( ignore )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, decisionCanBacktrack[2]);
				int LA2_0 = input.LA(1);

				if ((LA2_0==NEWLINE||LA2_0==WS))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:43:22: ignore
					{
					DebugLocation(43, 22);
					PushFollow(Follow._ignore_in_prog124);
					ignore2=ignore();
					PopFollow();

					stream_ignore.Add(ignore2.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(43, 30);
			PushFollow(Follow._expr_in_prog127);
			expr3=expr();
			PopFollow();

			stream_expr.Add(expr3.Tree);


			{
			// AST REWRITE
			// elements: declBlock, expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 43:35: -> ^( PROG ( declBlock )? expr )
			{
				DebugLocation(43, 38);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:43:38: ^( PROG ( declBlock )? expr )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(43, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROG, "PROG"), root_1);

				DebugLocation(43, 45);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:43:45: ( declBlock )?
				if (stream_declBlock.HasNext)
				{
					DebugLocation(43, 45);
					adaptor.AddChild(root_1, stream_declBlock.NextTree());

				}
				stream_declBlock.Reset();
				DebugLocation(43, 56);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prog", 1);
			LeaveRule("prog", 1);
			LeaveRule_prog();
	    }
	 	DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "prog"); }
		return retval;

	}
	// $ANTLR end "prog"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_declBlock() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_declBlock() {}

	// $ANTLR start "declBlock"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:48:1: declBlock : LEFT_CBRACKET ( ignore | decl )+ RIGHT_CBRACKET -> ^( VARDECLBLOCK ( decl )+ ) ;
	[GrammarRule("declBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> declBlock()
	{
		EnterRule_declBlock();
		EnterRule("declBlock", 2);
		TraceIn("declBlock", 2);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken LEFT_CBRACKET4 = default(IToken);
	    IToken RIGHT_CBRACKET7 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore5 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> decl6 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree LEFT_CBRACKET4_tree = default(CommonTree);
	    CommonTree RIGHT_CBRACKET7_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_LEFT_CBRACKET=new RewriteRuleITokenStream(adaptor,"token LEFT_CBRACKET");
	    RewriteRuleITokenStream stream_RIGHT_CBRACKET=new RewriteRuleITokenStream(adaptor,"token RIGHT_CBRACKET");
	    RewriteRuleSubtreeStream stream_decl=new RewriteRuleSubtreeStream(adaptor,"rule decl");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
		try { DebugEnterRule(GrammarFileName, "declBlock");
		DebugLocation(48, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:48:11: ( LEFT_CBRACKET ( ignore | decl )+ RIGHT_CBRACKET -> ^( VARDECLBLOCK ( decl )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:48:13: LEFT_CBRACKET ( ignore | decl )+ RIGHT_CBRACKET
			{
			DebugLocation(48, 13);
			LEFT_CBRACKET4=(IToken)Match(input,LEFT_CBRACKET,Follow._LEFT_CBRACKET_in_declBlock150);  
			stream_LEFT_CBRACKET.Add(LEFT_CBRACKET4);

			DebugLocation(48, 27);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:48:27: ( ignore | decl )+
			int cnt3=0;
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=3;
				try { DebugEnterDecision(3, decisionCanBacktrack[3]);
				int LA3_0 = input.LA(1);

				if ((LA3_0==NEWLINE||LA3_0==WS))
				{
					alt3 = 1;
				}
				else if ((LA3_0==ID))
				{
					alt3 = 2;
				}


				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:48:28: ignore
					{
					DebugLocation(48, 28);
					PushFollow(Follow._ignore_in_declBlock153);
					ignore5=ignore();
					PopFollow();

					stream_ignore.Add(ignore5.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:48:35: decl
					{
					DebugLocation(48, 35);
					PushFollow(Follow._decl_in_declBlock155);
					decl6=decl();
					PopFollow();

					stream_decl.Add(decl6.Tree);

					}
					break;

				default:
					if (cnt3 >= 1)
						goto loop3;

					EarlyExitException eee3 = new EarlyExitException( 3, input );
					DebugRecognitionException(eee3);
					throw eee3;
				}
				cnt3++;
			}
			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(48, 42);
			RIGHT_CBRACKET7=(IToken)Match(input,RIGHT_CBRACKET,Follow._RIGHT_CBRACKET_in_declBlock159);  
			stream_RIGHT_CBRACKET.Add(RIGHT_CBRACKET7);



			{
			// AST REWRITE
			// elements: decl
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 48:57: -> ^( VARDECLBLOCK ( decl )+ )
			{
				DebugLocation(48, 60);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:48:60: ^( VARDECLBLOCK ( decl )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(48, 62);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARDECLBLOCK, "VARDECLBLOCK"), root_1);

				DebugLocation(48, 75);
				if (!(stream_decl.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_decl.HasNext )
				{
					DebugLocation(48, 75);
					adaptor.AddChild(root_1, stream_decl.NextTree());

				}
				stream_decl.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declBlock", 2);
			LeaveRule("declBlock", 2);
			LeaveRule_declBlock();
	    }
	 	DebugLocation(49, 1);
		} finally { DebugExitRule(GrammarFileName, "declBlock"); }
		return retval;

	}
	// $ANTLR end "declBlock"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_decl() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_decl() {}

	// $ANTLR start "decl"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:1: decl : type ( ignore )* name ( ignore )* LEFT_PAREN ( ignore )* ( args )? RIGHT_PAREN ( ignore )* ';' -> ^( VARDECL name type ( args )? ) ;
	[GrammarRule("decl")]
	private AstParserRuleReturnScope<CommonTree, IToken> decl()
	{
		EnterRule_decl();
		EnterRule("decl", 3);
		TraceIn("decl", 3);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken LEFT_PAREN12 = default(IToken);
	    IToken RIGHT_PAREN15 = default(IToken);
	    IToken char_literal17 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> type8 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore9 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> name10 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore11 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore13 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> args14 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore16 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree LEFT_PAREN12_tree = default(CommonTree);
	    CommonTree RIGHT_PAREN15_tree = default(CommonTree);
	    CommonTree char_literal17_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_29=new RewriteRuleITokenStream(adaptor,"token 29");
	    RewriteRuleITokenStream stream_RIGHT_PAREN=new RewriteRuleITokenStream(adaptor,"token RIGHT_PAREN");
	    RewriteRuleITokenStream stream_LEFT_PAREN=new RewriteRuleITokenStream(adaptor,"token LEFT_PAREN");
	    RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args");
	    RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "decl");
		DebugLocation(51, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:6: ( type ( ignore )* name ( ignore )* LEFT_PAREN ( ignore )* ( args )? RIGHT_PAREN ( ignore )* ';' -> ^( VARDECL name type ( args )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:8: type ( ignore )* name ( ignore )* LEFT_PAREN ( ignore )* ( args )? RIGHT_PAREN ( ignore )* ';'
			{
			DebugLocation(51, 8);
			PushFollow(Follow._type_in_decl178);
			type8=type();
			PopFollow();

			stream_type.Add(type8.Tree);
			DebugLocation(51, 13);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:13: ( ignore )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, decisionCanBacktrack[4]);
				int LA4_0 = input.LA(1);

				if ((LA4_0==NEWLINE||LA4_0==WS))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:13: ignore
					{
					DebugLocation(51, 13);
					PushFollow(Follow._ignore_in_decl180);
					ignore9=ignore();
					PopFollow();

					stream_ignore.Add(ignore9.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(51, 21);
			PushFollow(Follow._name_in_decl183);
			name10=name();
			PopFollow();

			stream_name.Add(name10.Tree);
			DebugLocation(51, 26);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:26: ( ignore )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, decisionCanBacktrack[5]);
				int LA5_0 = input.LA(1);

				if ((LA5_0==NEWLINE||LA5_0==WS))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:26: ignore
					{
					DebugLocation(51, 26);
					PushFollow(Follow._ignore_in_decl185);
					ignore11=ignore();
					PopFollow();

					stream_ignore.Add(ignore11.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(51, 34);
			LEFT_PAREN12=(IToken)Match(input,LEFT_PAREN,Follow._LEFT_PAREN_in_decl188);  
			stream_LEFT_PAREN.Add(LEFT_PAREN12);

			DebugLocation(51, 45);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:45: ( ignore )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, decisionCanBacktrack[6]);
				int LA6_0 = input.LA(1);

				if ((LA6_0==NEWLINE||LA6_0==WS))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:45: ignore
					{
					DebugLocation(51, 45);
					PushFollow(Follow._ignore_in_decl190);
					ignore13=ignore();
					PopFollow();

					stream_ignore.Add(ignore13.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(51, 53);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:53: ( args )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, decisionCanBacktrack[7]);
			int LA7_0 = input.LA(1);

			if (((LA7_0>=FLOAT && LA7_0<=INT)))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:53: args
				{
				DebugLocation(51, 53);
				PushFollow(Follow._args_in_decl193);
				args14=args();
				PopFollow();

				stream_args.Add(args14.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(51, 59);
			RIGHT_PAREN15=(IToken)Match(input,RIGHT_PAREN,Follow._RIGHT_PAREN_in_decl196);  
			stream_RIGHT_PAREN.Add(RIGHT_PAREN15);

			DebugLocation(51, 71);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:71: ( ignore )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, decisionCanBacktrack[8]);
				int LA8_0 = input.LA(1);

				if ((LA8_0==NEWLINE||LA8_0==WS))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:71: ignore
					{
					DebugLocation(51, 71);
					PushFollow(Follow._ignore_in_decl198);
					ignore16=ignore();
					PopFollow();

					stream_ignore.Add(ignore16.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(51, 79);
			char_literal17=(IToken)Match(input,29,Follow._29_in_decl201);  
			stream_29.Add(char_literal17);



			{
			// AST REWRITE
			// elements: name, args, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 51:83: -> ^( VARDECL name type ( args )? )
			{
				DebugLocation(51, 86);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:86: ^( VARDECL name type ( args )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(51, 88);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARDECL, "VARDECL"), root_1);

				DebugLocation(51, 96);
				adaptor.AddChild(root_1, stream_name.NextTree());
				DebugLocation(51, 101);
				adaptor.AddChild(root_1, stream_type.NextTree());
				DebugLocation(51, 106);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:51:106: ( args )?
				if (stream_args.HasNext)
				{
					DebugLocation(51, 106);
					adaptor.AddChild(root_1, stream_args.NextTree());

				}
				stream_args.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decl", 3);
			LeaveRule("decl", 3);
			LeaveRule_decl();
	    }
	 	DebugLocation(52, 1);
		} finally { DebugExitRule(GrammarFileName, "decl"); }
		return retval;

	}
	// $ANTLR end "decl"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_type() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_type() {}

	// $ANTLR start "type"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:54:1: type : ID -> ^( VARTYPE ID ) ;
	[GrammarRule("type")]
	private AstParserRuleReturnScope<CommonTree, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 4);
		TraceIn("type", 4);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken ID18 = default(IToken);

	    CommonTree ID18_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");

		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(54, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:54:6: ( ID -> ^( VARTYPE ID ) )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:54:8: ID
			{
			DebugLocation(54, 8);
			ID18=(IToken)Match(input,ID,Follow._ID_in_type225);  
			stream_ID.Add(ID18);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 54:11: -> ^( VARTYPE ID )
			{
				DebugLocation(54, 14);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:54:14: ^( VARTYPE ID )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(54, 16);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARTYPE, "VARTYPE"), root_1);

				DebugLocation(54, 24);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 4);
			LeaveRule("type", 4);
			LeaveRule_type();
	    }
	 	DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_name() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_name() {}

	// $ANTLR start "name"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:57:1: name : ID -> ^( VARNAME ID ) ;
	[GrammarRule("name")]
	private AstParserRuleReturnScope<CommonTree, IToken> name()
	{
		EnterRule_name();
		EnterRule("name", 5);
		TraceIn("name", 5);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken ID19 = default(IToken);

	    CommonTree ID19_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");

		try { DebugEnterRule(GrammarFileName, "name");
		DebugLocation(57, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:58:2: ( ID -> ^( VARNAME ID ) )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:58:4: ID
			{
			DebugLocation(58, 4);
			ID19=(IToken)Match(input,ID,Follow._ID_in_name246);  
			stream_ID.Add(ID19);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 58:7: -> ^( VARNAME ID )
			{
				DebugLocation(58, 10);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:58:10: ^( VARNAME ID )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(58, 12);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARNAME, "VARNAME"), root_1);

				DebugLocation(58, 20);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name", 5);
			LeaveRule("name", 5);
			LeaveRule_name();
	    }
	 	DebugLocation(59, 1);
		} finally { DebugExitRule(GrammarFileName, "name"); }
		return retval;

	}
	// $ANTLR end "name"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_args() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_args() {}

	// $ANTLR start "args"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:1: args : arg ( ignore )* ( ',' ( ignore )* arg ( ignore )* )* -> ^( VARARGS ( arg )+ ) ;
	[GrammarRule("args")]
	private AstParserRuleReturnScope<CommonTree, IToken> args()
	{
		EnterRule_args();
		EnterRule("args", 6);
		TraceIn("args", 6);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken char_literal22 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> arg20 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore21 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> arg24 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore25 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree char_literal22_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_28=new RewriteRuleITokenStream(adaptor,"token 28");
	    RewriteRuleSubtreeStream stream_arg=new RewriteRuleSubtreeStream(adaptor,"rule arg");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
		try { DebugEnterRule(GrammarFileName, "args");
		DebugLocation(61, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:6: ( arg ( ignore )* ( ',' ( ignore )* arg ( ignore )* )* -> ^( VARARGS ( arg )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:8: arg ( ignore )* ( ',' ( ignore )* arg ( ignore )* )*
			{
			DebugLocation(61, 8);
			PushFollow(Follow._arg_in_args265);
			arg20=arg();
			PopFollow();

			stream_arg.Add(arg20.Tree);
			DebugLocation(61, 12);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:12: ( ignore )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, decisionCanBacktrack[9]);
				int LA9_0 = input.LA(1);

				if ((LA9_0==NEWLINE||LA9_0==WS))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:12: ignore
					{
					DebugLocation(61, 12);
					PushFollow(Follow._ignore_in_args267);
					ignore21=ignore();
					PopFollow();

					stream_ignore.Add(ignore21.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(61, 20);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:20: ( ',' ( ignore )* arg ( ignore )* )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, decisionCanBacktrack[12]);
				int LA12_0 = input.LA(1);

				if ((LA12_0==28))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:22: ',' ( ignore )* arg ( ignore )*
					{
					DebugLocation(61, 22);
					char_literal22=(IToken)Match(input,28,Follow._28_in_args272);  
					stream_28.Add(char_literal22);

					DebugLocation(61, 26);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:26: ( ignore )*
					try { DebugEnterSubRule(10);
					while (true)
					{
						int alt10=2;
						try { DebugEnterDecision(10, decisionCanBacktrack[10]);
						int LA10_0 = input.LA(1);

						if ((LA10_0==NEWLINE||LA10_0==WS))
						{
							alt10 = 1;
						}


						} finally { DebugExitDecision(10); }
						switch ( alt10 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:26: ignore
							{
							DebugLocation(61, 26);
							PushFollow(Follow._ignore_in_args274);
							ignore23=ignore();
							PopFollow();

							stream_ignore.Add(ignore23.Tree);

							}
							break;

						default:
							goto loop10;
						}
					}

					loop10:
						;

					} finally { DebugExitSubRule(10); }

					DebugLocation(61, 34);
					PushFollow(Follow._arg_in_args277);
					arg24=arg();
					PopFollow();

					stream_arg.Add(arg24.Tree);
					DebugLocation(61, 38);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:38: ( ignore )*
					try { DebugEnterSubRule(11);
					while (true)
					{
						int alt11=2;
						try { DebugEnterDecision(11, decisionCanBacktrack[11]);
						int LA11_0 = input.LA(1);

						if ((LA11_0==NEWLINE||LA11_0==WS))
						{
							alt11 = 1;
						}


						} finally { DebugExitDecision(11); }
						switch ( alt11 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:38: ignore
							{
							DebugLocation(61, 38);
							PushFollow(Follow._ignore_in_args279);
							ignore25=ignore();
							PopFollow();

							stream_ignore.Add(ignore25.Tree);

							}
							break;

						default:
							goto loop11;
						}
					}

					loop11:
						;

					} finally { DebugExitSubRule(11); }


					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }



			{
			// AST REWRITE
			// elements: arg
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 61:49: -> ^( VARARGS ( arg )+ )
			{
				DebugLocation(61, 52);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:61:52: ^( VARARGS ( arg )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(61, 54);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARARGS, "VARARGS"), root_1);

				DebugLocation(61, 62);
				if (!(stream_arg.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_arg.HasNext )
				{
					DebugLocation(61, 62);
					adaptor.AddChild(root_1, stream_arg.NextTree());

				}
				stream_arg.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("args", 6);
			LeaveRule("args", 6);
			LeaveRule_args();
	    }
	 	DebugLocation(62, 1);
		} finally { DebugExitRule(GrammarFileName, "args"); }
		return retval;

	}
	// $ANTLR end "args"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_arg() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_arg() {}

	// $ANTLR start "arg"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:64:1: arg : ( ID -> ^( ARGTYPE_DELEGATE ID ) | INT -> ^( ARGTYPE_INT INT ) | FLOAT -> ^( ARGTYPE_FLOAT FLOAT ) );
	[GrammarRule("arg")]
	private AstParserRuleReturnScope<CommonTree, IToken> arg()
	{
		EnterRule_arg();
		EnterRule("arg", 7);
		TraceIn("arg", 7);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken ID26 = default(IToken);
	    IToken INT27 = default(IToken);
	    IToken FLOAT28 = default(IToken);

	    CommonTree ID26_tree = default(CommonTree);
	    CommonTree INT27_tree = default(CommonTree);
	    CommonTree FLOAT28_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_FLOAT=new RewriteRuleITokenStream(adaptor,"token FLOAT");
	    RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
	    RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");

		try { DebugEnterRule(GrammarFileName, "arg");
		DebugLocation(64, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:64:5: ( ID -> ^( ARGTYPE_DELEGATE ID ) | INT -> ^( ARGTYPE_INT INT ) | FLOAT -> ^( ARGTYPE_FLOAT FLOAT ) )
			int alt13=3;
			try { DebugEnterDecision(13, decisionCanBacktrack[13]);
			switch (input.LA(1))
			{
			case ID:
				{
				alt13 = 1;
				}
				break;
			case INT:
				{
				alt13 = 2;
				}
				break;
			case FLOAT:
				{
				alt13 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:64:7: ID
				{
				DebugLocation(64, 7);
				ID26=(IToken)Match(input,ID,Follow._ID_in_arg302);  
				stream_ID.Add(ID26);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 64:10: -> ^( ARGTYPE_DELEGATE ID )
				{
					DebugLocation(64, 13);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:64:13: ^( ARGTYPE_DELEGATE ID )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(64, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARGTYPE_DELEGATE, "ARGTYPE_DELEGATE"), root_1);

					DebugLocation(64, 32);
					adaptor.AddChild(root_1, stream_ID.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:65:4: INT
				{
				DebugLocation(65, 4);
				INT27=(IToken)Match(input,INT,Follow._INT_in_arg315);  
				stream_INT.Add(INT27);



				{
				// AST REWRITE
				// elements: INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 65:8: -> ^( ARGTYPE_INT INT )
				{
					DebugLocation(65, 11);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:65:11: ^( ARGTYPE_INT INT )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(65, 13);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARGTYPE_INT, "ARGTYPE_INT"), root_1);

					DebugLocation(65, 25);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:66:4: FLOAT
				{
				DebugLocation(66, 4);
				FLOAT28=(IToken)Match(input,FLOAT,Follow._FLOAT_in_arg328);  
				stream_FLOAT.Add(FLOAT28);



				{
				// AST REWRITE
				// elements: FLOAT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 66:10: -> ^( ARGTYPE_FLOAT FLOAT )
				{
					DebugLocation(66, 13);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:66:13: ^( ARGTYPE_FLOAT FLOAT )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(66, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARGTYPE_FLOAT, "ARGTYPE_FLOAT"), root_1);

					DebugLocation(66, 29);
					adaptor.AddChild(root_1, stream_FLOAT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arg", 7);
			LeaveRule("arg", 7);
			LeaveRule_arg();
	    }
	 	DebugLocation(67, 1);
		} finally { DebugExitRule(GrammarFileName, "arg"); }
		return retval;

	}
	// $ANTLR end "arg"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_expr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_expr() {}

	// $ANTLR start "expr"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:71:1: expr : ( orExpr ( ignore )? )+ -> ^( PROGEXPR orExpr PROGEXPR_RESTART ) ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 8);
		TraceIn("expr", 8);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    AstParserRuleReturnScope<CommonTree, IToken> orExpr29 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore30 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    RewriteRuleSubtreeStream stream_orExpr=new RewriteRuleSubtreeStream(adaptor,"rule orExpr");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(71, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:71:6: ( ( orExpr ( ignore )? )+ -> ^( PROGEXPR orExpr PROGEXPR_RESTART ) )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:71:8: ( orExpr ( ignore )? )+
			{
			DebugLocation(71, 8);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:71:8: ( orExpr ( ignore )? )+
			int cnt15=0;
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, decisionCanBacktrack[15]);
				int LA15_0 = input.LA(1);

				if ((LA15_0==ID||LA15_0==LEFT_PAREN||LA15_0==NOT))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:71:9: orExpr ( ignore )?
					{
					DebugLocation(71, 9);
					PushFollow(Follow._orExpr_in_expr349);
					orExpr29=orExpr();
					PopFollow();

					stream_orExpr.Add(orExpr29.Tree);
					DebugLocation(71, 16);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:71:16: ( ignore )?
					int alt14=2;
					try { DebugEnterSubRule(14);
					try { DebugEnterDecision(14, decisionCanBacktrack[14]);
					int LA14_0 = input.LA(1);

					if ((LA14_0==NEWLINE||LA14_0==WS))
					{
						alt14 = 1;
					}
					} finally { DebugExitDecision(14); }
					switch (alt14)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:71:16: ignore
						{
						DebugLocation(71, 16);
						PushFollow(Follow._ignore_in_expr351);
						ignore30=ignore();
						PopFollow();

						stream_ignore.Add(ignore30.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(14); }


					}
					break;

				default:
					if (cnt15 >= 1)
						goto loop15;

					EarlyExitException eee15 = new EarlyExitException( 15, input );
					DebugRecognitionException(eee15);
					throw eee15;
				}
				cnt15++;
			}
			loop15:
				;

			} finally { DebugExitSubRule(15); }



			{
			// AST REWRITE
			// elements: orExpr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 71:26: -> ^( PROGEXPR orExpr PROGEXPR_RESTART )
			{
				DebugLocation(71, 29);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:71:29: ^( PROGEXPR orExpr PROGEXPR_RESTART )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(71, 32);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROGEXPR, "PROGEXPR"), root_1);

				DebugLocation(71, 41);
				adaptor.AddChild(root_1, stream_orExpr.NextTree());
				DebugLocation(71, 48);
				adaptor.AddChild(root_1, (CommonTree)adaptor.Create(PROGEXPR_RESTART, "PROGEXPR_RESTART"));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 8);
			LeaveRule("expr", 8);
			LeaveRule_expr();
	    }
	 	DebugLocation(72, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_orExpr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_orExpr() {}

	// $ANTLR start "orExpr"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:1: orExpr : (lhs= xorExpr -> $lhs) ( ( ignore )* OR ( ignore )* rhs= xorExpr -> ^( OR $orExpr $rhs) )* ;
	[GrammarRule("orExpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> orExpr()
	{
		EnterRule_orExpr();
		EnterRule("orExpr", 9);
		TraceIn("orExpr", 9);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken OR32 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> lhs = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> rhs = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore31 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore33 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree OR32_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_OR=new RewriteRuleITokenStream(adaptor,"token OR");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_xorExpr=new RewriteRuleSubtreeStream(adaptor,"rule xorExpr");
		try { DebugEnterRule(GrammarFileName, "orExpr");
		DebugLocation(74, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:8: ( (lhs= xorExpr -> $lhs) ( ( ignore )* OR ( ignore )* rhs= xorExpr -> ^( OR $orExpr $rhs) )* )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:10: (lhs= xorExpr -> $lhs) ( ( ignore )* OR ( ignore )* rhs= xorExpr -> ^( OR $orExpr $rhs) )*
			{
			DebugLocation(74, 10);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:10: (lhs= xorExpr -> $lhs)
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:11: lhs= xorExpr
			{
			DebugLocation(74, 14);
			PushFollow(Follow._xorExpr_in_orExpr380);
			lhs=xorExpr();
			PopFollow();

			stream_xorExpr.Add(lhs.Tree);


			{
			// AST REWRITE
			// elements: lhs
			// token labels: 
			// rule labels: lhs, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"rule lhs",lhs!=null?lhs.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 74:23: -> $lhs
			{
				DebugLocation(74, 27);
				adaptor.AddChild(root_0, stream_lhs.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(74, 32);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:32: ( ( ignore )* OR ( ignore )* rhs= xorExpr -> ^( OR $orExpr $rhs) )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, decisionCanBacktrack[18]);
				int LA18_0 = input.LA(1);

				if ((LA18_0==NEWLINE||LA18_0==WS))
				{
					int LA18_1 = input.LA(2);

					if ((LA18_1==NEWLINE||LA18_1==OR||LA18_1==WS))
					{
						alt18 = 1;
					}


				}
				else if ((LA18_0==OR))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:34: ( ignore )* OR ( ignore )* rhs= xorExpr
					{
					DebugLocation(74, 34);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:34: ( ignore )*
					try { DebugEnterSubRule(16);
					while (true)
					{
						int alt16=2;
						try { DebugEnterDecision(16, decisionCanBacktrack[16]);
						int LA16_0 = input.LA(1);

						if ((LA16_0==NEWLINE||LA16_0==WS))
						{
							alt16 = 1;
						}


						} finally { DebugExitDecision(16); }
						switch ( alt16 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:34: ignore
							{
							DebugLocation(74, 34);
							PushFollow(Follow._ignore_in_orExpr390);
							ignore31=ignore();
							PopFollow();

							stream_ignore.Add(ignore31.Tree);

							}
							break;

						default:
							goto loop16;
						}
					}

					loop16:
						;

					} finally { DebugExitSubRule(16); }

					DebugLocation(74, 42);
					OR32=(IToken)Match(input,OR,Follow._OR_in_orExpr393);  
					stream_OR.Add(OR32);

					DebugLocation(74, 45);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:45: ( ignore )*
					try { DebugEnterSubRule(17);
					while (true)
					{
						int alt17=2;
						try { DebugEnterDecision(17, decisionCanBacktrack[17]);
						int LA17_0 = input.LA(1);

						if ((LA17_0==NEWLINE||LA17_0==WS))
						{
							alt17 = 1;
						}


						} finally { DebugExitDecision(17); }
						switch ( alt17 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:45: ignore
							{
							DebugLocation(74, 45);
							PushFollow(Follow._ignore_in_orExpr395);
							ignore33=ignore();
							PopFollow();

							stream_ignore.Add(ignore33.Tree);

							}
							break;

						default:
							goto loop17;
						}
					}

					loop17:
						;

					} finally { DebugExitSubRule(17); }

					DebugLocation(74, 56);
					PushFollow(Follow._xorExpr_in_orExpr400);
					rhs=xorExpr();
					PopFollow();

					stream_xorExpr.Add(rhs.Tree);


					{
					// AST REWRITE
					// elements: OR, orExpr, rhs
					// token labels: 
					// rule labels: rhs, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_rhs=new RewriteRuleSubtreeStream(adaptor,"rule rhs",rhs!=null?rhs.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 74:65: -> ^( OR $orExpr $rhs)
					{
						DebugLocation(74, 68);
						// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:74:68: ^( OR $orExpr $rhs)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(74, 70);
						root_1 = (CommonTree)adaptor.BecomeRoot(stream_OR.NextNode(), root_1);

						DebugLocation(74, 74);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(74, 82);
						adaptor.AddChild(root_1, stream_rhs.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orExpr", 9);
			LeaveRule("orExpr", 9);
			LeaveRule_orExpr();
	    }
	 	DebugLocation(75, 1);
		} finally { DebugExitRule(GrammarFileName, "orExpr"); }
		return retval;

	}
	// $ANTLR end "orExpr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_xorExpr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_xorExpr() {}

	// $ANTLR start "xorExpr"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:1: xorExpr : (lhs= andExpr -> $lhs) ( ( ignore )* XOR ( ignore )* rhs= andExpr -> ^( XOR $xorExpr $rhs) )* ;
	[GrammarRule("xorExpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> xorExpr()
	{
		EnterRule_xorExpr();
		EnterRule("xorExpr", 10);
		TraceIn("xorExpr", 10);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken XOR35 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> lhs = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> rhs = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore34 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore36 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree XOR35_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_XOR=new RewriteRuleITokenStream(adaptor,"token XOR");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_andExpr=new RewriteRuleSubtreeStream(adaptor,"rule andExpr");
		try { DebugEnterRule(GrammarFileName, "xorExpr");
		DebugLocation(77, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:9: ( (lhs= andExpr -> $lhs) ( ( ignore )* XOR ( ignore )* rhs= andExpr -> ^( XOR $xorExpr $rhs) )* )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:11: (lhs= andExpr -> $lhs) ( ( ignore )* XOR ( ignore )* rhs= andExpr -> ^( XOR $xorExpr $rhs) )*
			{
			DebugLocation(77, 11);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:11: (lhs= andExpr -> $lhs)
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:12: lhs= andExpr
			{
			DebugLocation(77, 15);
			PushFollow(Follow._andExpr_in_xorExpr428);
			lhs=andExpr();
			PopFollow();

			stream_andExpr.Add(lhs.Tree);


			{
			// AST REWRITE
			// elements: lhs
			// token labels: 
			// rule labels: lhs, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"rule lhs",lhs!=null?lhs.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 77:24: -> $lhs
			{
				DebugLocation(77, 28);
				adaptor.AddChild(root_0, stream_lhs.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(77, 33);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:33: ( ( ignore )* XOR ( ignore )* rhs= andExpr -> ^( XOR $xorExpr $rhs) )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, decisionCanBacktrack[21]);
				try
				{
					alt21 = dfa21.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:35: ( ignore )* XOR ( ignore )* rhs= andExpr
					{
					DebugLocation(77, 35);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:35: ( ignore )*
					try { DebugEnterSubRule(19);
					while (true)
					{
						int alt19=2;
						try { DebugEnterDecision(19, decisionCanBacktrack[19]);
						int LA19_0 = input.LA(1);

						if ((LA19_0==NEWLINE||LA19_0==WS))
						{
							alt19 = 1;
						}


						} finally { DebugExitDecision(19); }
						switch ( alt19 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:35: ignore
							{
							DebugLocation(77, 35);
							PushFollow(Follow._ignore_in_xorExpr438);
							ignore34=ignore();
							PopFollow();

							stream_ignore.Add(ignore34.Tree);

							}
							break;

						default:
							goto loop19;
						}
					}

					loop19:
						;

					} finally { DebugExitSubRule(19); }

					DebugLocation(77, 43);
					XOR35=(IToken)Match(input,XOR,Follow._XOR_in_xorExpr441);  
					stream_XOR.Add(XOR35);

					DebugLocation(77, 47);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:47: ( ignore )*
					try { DebugEnterSubRule(20);
					while (true)
					{
						int alt20=2;
						try { DebugEnterDecision(20, decisionCanBacktrack[20]);
						int LA20_0 = input.LA(1);

						if ((LA20_0==NEWLINE||LA20_0==WS))
						{
							alt20 = 1;
						}


						} finally { DebugExitDecision(20); }
						switch ( alt20 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:47: ignore
							{
							DebugLocation(77, 47);
							PushFollow(Follow._ignore_in_xorExpr443);
							ignore36=ignore();
							PopFollow();

							stream_ignore.Add(ignore36.Tree);

							}
							break;

						default:
							goto loop20;
						}
					}

					loop20:
						;

					} finally { DebugExitSubRule(20); }

					DebugLocation(77, 58);
					PushFollow(Follow._andExpr_in_xorExpr448);
					rhs=andExpr();
					PopFollow();

					stream_andExpr.Add(rhs.Tree);


					{
					// AST REWRITE
					// elements: XOR, xorExpr, rhs
					// token labels: 
					// rule labels: rhs, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_rhs=new RewriteRuleSubtreeStream(adaptor,"rule rhs",rhs!=null?rhs.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 77:67: -> ^( XOR $xorExpr $rhs)
					{
						DebugLocation(77, 70);
						// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:77:70: ^( XOR $xorExpr $rhs)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(77, 72);
						root_1 = (CommonTree)adaptor.BecomeRoot(stream_XOR.NextNode(), root_1);

						DebugLocation(77, 77);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(77, 86);
						adaptor.AddChild(root_1, stream_rhs.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xorExpr", 10);
			LeaveRule("xorExpr", 10);
			LeaveRule_xorExpr();
	    }
	 	DebugLocation(78, 1);
		} finally { DebugExitRule(GrammarFileName, "xorExpr"); }
		return retval;

	}
	// $ANTLR end "xorExpr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_andExpr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_andExpr() {}

	// $ANTLR start "andExpr"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:1: andExpr : (lhs= term -> $lhs) ( ( ignore )* AND ( ignore )* rhs= term -> ^( AND $andExpr $rhs) )* ;
	[GrammarRule("andExpr")]
	private AstParserRuleReturnScope<CommonTree, IToken> andExpr()
	{
		EnterRule_andExpr();
		EnterRule("andExpr", 11);
		TraceIn("andExpr", 11);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken AND38 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> lhs = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> rhs = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore37 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore39 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree AND38_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_AND=new RewriteRuleITokenStream(adaptor,"token AND");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term");
		try { DebugEnterRule(GrammarFileName, "andExpr");
		DebugLocation(80, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:9: ( (lhs= term -> $lhs) ( ( ignore )* AND ( ignore )* rhs= term -> ^( AND $andExpr $rhs) )* )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:11: (lhs= term -> $lhs) ( ( ignore )* AND ( ignore )* rhs= term -> ^( AND $andExpr $rhs) )*
			{
			DebugLocation(80, 11);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:11: (lhs= term -> $lhs)
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:12: lhs= term
			{
			DebugLocation(80, 15);
			PushFollow(Follow._term_in_andExpr477);
			lhs=term();
			PopFollow();

			stream_term.Add(lhs.Tree);


			{
			// AST REWRITE
			// elements: lhs
			// token labels: 
			// rule labels: lhs, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_lhs=new RewriteRuleSubtreeStream(adaptor,"rule lhs",lhs!=null?lhs.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 80:21: -> $lhs
			{
				DebugLocation(80, 25);
				adaptor.AddChild(root_0, stream_lhs.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(80, 30);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:30: ( ( ignore )* AND ( ignore )* rhs= term -> ^( AND $andExpr $rhs) )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, decisionCanBacktrack[24]);
				try
				{
					alt24 = dfa24.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:32: ( ignore )* AND ( ignore )* rhs= term
					{
					DebugLocation(80, 32);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:32: ( ignore )*
					try { DebugEnterSubRule(22);
					while (true)
					{
						int alt22=2;
						try { DebugEnterDecision(22, decisionCanBacktrack[22]);
						int LA22_0 = input.LA(1);

						if ((LA22_0==NEWLINE||LA22_0==WS))
						{
							alt22 = 1;
						}


						} finally { DebugExitDecision(22); }
						switch ( alt22 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:32: ignore
							{
							DebugLocation(80, 32);
							PushFollow(Follow._ignore_in_andExpr487);
							ignore37=ignore();
							PopFollow();

							stream_ignore.Add(ignore37.Tree);

							}
							break;

						default:
							goto loop22;
						}
					}

					loop22:
						;

					} finally { DebugExitSubRule(22); }

					DebugLocation(80, 40);
					AND38=(IToken)Match(input,AND,Follow._AND_in_andExpr490);  
					stream_AND.Add(AND38);

					DebugLocation(80, 44);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:44: ( ignore )*
					try { DebugEnterSubRule(23);
					while (true)
					{
						int alt23=2;
						try { DebugEnterDecision(23, decisionCanBacktrack[23]);
						int LA23_0 = input.LA(1);

						if ((LA23_0==NEWLINE||LA23_0==WS))
						{
							alt23 = 1;
						}


						} finally { DebugExitDecision(23); }
						switch ( alt23 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:44: ignore
							{
							DebugLocation(80, 44);
							PushFollow(Follow._ignore_in_andExpr492);
							ignore39=ignore();
							PopFollow();

							stream_ignore.Add(ignore39.Tree);

							}
							break;

						default:
							goto loop23;
						}
					}

					loop23:
						;

					} finally { DebugExitSubRule(23); }

					DebugLocation(80, 55);
					PushFollow(Follow._term_in_andExpr497);
					rhs=term();
					PopFollow();

					stream_term.Add(rhs.Tree);


					{
					// AST REWRITE
					// elements: andExpr, rhs, AND
					// token labels: 
					// rule labels: rhs, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_rhs=new RewriteRuleSubtreeStream(adaptor,"rule rhs",rhs!=null?rhs.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 80:61: -> ^( AND $andExpr $rhs)
					{
						DebugLocation(80, 64);
						// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:80:64: ^( AND $andExpr $rhs)
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(80, 66);
						root_1 = (CommonTree)adaptor.BecomeRoot(stream_AND.NextNode(), root_1);

						DebugLocation(80, 71);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(80, 80);
						adaptor.AddChild(root_1, stream_rhs.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("andExpr", 11);
			LeaveRule("andExpr", 11);
			LeaveRule_andExpr();
	    }
	 	DebugLocation(81, 1);
		} finally { DebugExitRule(GrammarFileName, "andExpr"); }
		return retval;

	}
	// $ANTLR end "andExpr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_term() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_term() {}

	// $ANTLR start "term"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:83:1: term : ( NOT ( ignore )* atom -> ^( NOT atom ) | atom -> atom );
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 12);
		TraceIn("term", 12);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken NOT40 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> atom42 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> atom43 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree NOT40_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(83, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:83:7: ( NOT ( ignore )* atom -> ^( NOT atom ) | atom -> atom )
			int alt26=2;
			try { DebugEnterDecision(26, decisionCanBacktrack[26]);
			int LA26_0 = input.LA(1);

			if ((LA26_0==NOT))
			{
				alt26 = 1;
			}
			else if ((LA26_0==ID||LA26_0==LEFT_PAREN))
			{
				alt26 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:83:9: NOT ( ignore )* atom
				{
				DebugLocation(83, 9);
				NOT40=(IToken)Match(input,NOT,Follow._NOT_in_term524);  
				stream_NOT.Add(NOT40);

				DebugLocation(83, 13);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:83:13: ( ignore )*
				try { DebugEnterSubRule(25);
				while (true)
				{
					int alt25=2;
					try { DebugEnterDecision(25, decisionCanBacktrack[25]);
					int LA25_0 = input.LA(1);

					if ((LA25_0==NEWLINE||LA25_0==WS))
					{
						alt25 = 1;
					}


					} finally { DebugExitDecision(25); }
					switch ( alt25 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:83:13: ignore
						{
						DebugLocation(83, 13);
						PushFollow(Follow._ignore_in_term526);
						ignore41=ignore();
						PopFollow();

						stream_ignore.Add(ignore41.Tree);

						}
						break;

					default:
						goto loop25;
					}
				}

				loop25:
					;

				} finally { DebugExitSubRule(25); }

				DebugLocation(83, 21);
				PushFollow(Follow._atom_in_term529);
				atom42=atom();
				PopFollow();

				stream_atom.Add(atom42.Tree);


				{
				// AST REWRITE
				// elements: NOT, atom
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 83:26: -> ^( NOT atom )
				{
					DebugLocation(83, 29);
					// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:83:29: ^( NOT atom )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(83, 32);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_NOT.NextNode(), root_1);

					DebugLocation(83, 36);
					adaptor.AddChild(root_1, stream_atom.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:84:4: atom
				{
				DebugLocation(84, 4);
				PushFollow(Follow._atom_in_term544);
				atom43=atom();
				PopFollow();

				stream_atom.Add(atom43.Tree);


				{
				// AST REWRITE
				// elements: atom
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 84:9: -> atom
				{
					DebugLocation(84, 12);
					adaptor.AddChild(root_0, stream_atom.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 12);
			LeaveRule("term", 12);
			LeaveRule_term();
	    }
	 	DebugLocation(85, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_atom() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_atom() {}

	// $ANTLR start "atom"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:87:1: atom : ( ID -> ID | LEFT_PAREN ( ignore )* orExpr RIGHT_PAREN -> orExpr );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<CommonTree, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 13);
		TraceIn("atom", 13);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken ID44 = default(IToken);
	    IToken LEFT_PAREN45 = default(IToken);
	    IToken RIGHT_PAREN48 = default(IToken);
	    AstParserRuleReturnScope<CommonTree, IToken> ignore46 = default(AstParserRuleReturnScope<CommonTree, IToken>);
	    AstParserRuleReturnScope<CommonTree, IToken> orExpr47 = default(AstParserRuleReturnScope<CommonTree, IToken>);

	    CommonTree ID44_tree = default(CommonTree);
	    CommonTree LEFT_PAREN45_tree = default(CommonTree);
	    CommonTree RIGHT_PAREN48_tree = default(CommonTree);
	    RewriteRuleITokenStream stream_RIGHT_PAREN=new RewriteRuleITokenStream(adaptor,"token RIGHT_PAREN");
	    RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
	    RewriteRuleITokenStream stream_LEFT_PAREN=new RewriteRuleITokenStream(adaptor,"token LEFT_PAREN");
	    RewriteRuleSubtreeStream stream_ignore=new RewriteRuleSubtreeStream(adaptor,"rule ignore");
	    RewriteRuleSubtreeStream stream_orExpr=new RewriteRuleSubtreeStream(adaptor,"rule orExpr");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(87, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:87:6: ( ID -> ID | LEFT_PAREN ( ignore )* orExpr RIGHT_PAREN -> orExpr )
			int alt28=2;
			try { DebugEnterDecision(28, decisionCanBacktrack[28]);
			int LA28_0 = input.LA(1);

			if ((LA28_0==ID))
			{
				alt28 = 1;
			}
			else if ((LA28_0==LEFT_PAREN))
			{
				alt28 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:87:8: ID
				{
				DebugLocation(87, 8);
				ID44=(IToken)Match(input,ID,Follow._ID_in_atom559);  
				stream_ID.Add(ID44);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 87:11: -> ID
				{
					DebugLocation(87, 14);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:88:5: LEFT_PAREN ( ignore )* orExpr RIGHT_PAREN
				{
				DebugLocation(88, 5);
				LEFT_PAREN45=(IToken)Match(input,LEFT_PAREN,Follow._LEFT_PAREN_in_atom569);  
				stream_LEFT_PAREN.Add(LEFT_PAREN45);

				DebugLocation(88, 16);
				// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:88:16: ( ignore )*
				try { DebugEnterSubRule(27);
				while (true)
				{
					int alt27=2;
					try { DebugEnterDecision(27, decisionCanBacktrack[27]);
					int LA27_0 = input.LA(1);

					if ((LA27_0==NEWLINE||LA27_0==WS))
					{
						alt27 = 1;
					}


					} finally { DebugExitDecision(27); }
					switch ( alt27 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:88:16: ignore
						{
						DebugLocation(88, 16);
						PushFollow(Follow._ignore_in_atom571);
						ignore46=ignore();
						PopFollow();

						stream_ignore.Add(ignore46.Tree);

						}
						break;

					default:
						goto loop27;
					}
				}

				loop27:
					;

				} finally { DebugExitSubRule(27); }

				DebugLocation(88, 24);
				PushFollow(Follow._orExpr_in_atom574);
				orExpr47=orExpr();
				PopFollow();

				stream_orExpr.Add(orExpr47.Tree);
				DebugLocation(88, 31);
				RIGHT_PAREN48=(IToken)Match(input,RIGHT_PAREN,Follow._RIGHT_PAREN_in_atom576);  
				stream_RIGHT_PAREN.Add(RIGHT_PAREN48);



				{
				// AST REWRITE
				// elements: orExpr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 88:43: -> orExpr
				{
					DebugLocation(88, 46);
					adaptor.AddChild(root_0, stream_orExpr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 13);
			LeaveRule("atom", 13);
			LeaveRule_atom();
	    }
	 	DebugLocation(89, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_ignore() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_ignore() {}

	// $ANTLR start "ignore"
	// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:91:1: ignore : ( WS | NEWLINE ) ;
	[GrammarRule("ignore")]
	private AstParserRuleReturnScope<CommonTree, IToken> ignore()
	{
		EnterRule_ignore();
		EnterRule("ignore", 14);
		TraceIn("ignore", 14);
	    AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    CommonTree root_0 = default(CommonTree);

	    IToken set49 = default(IToken);

	    CommonTree set49_tree = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "ignore");
		DebugLocation(91, 1);
		try
		{
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:91:9: ( ( WS | NEWLINE ) )
			DebugEnterAlt(1);
			// C:\\Users\\zeano\\Dropbox\\Neo\\StateMachine\\Internal\\StateMachineTransition.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(91, 9);

			set49=(IToken)input.LT(1);
			if (input.LA(1)==NEWLINE||input.LA(1)==WS)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set49));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ignore", 14);
			LeaveRule("ignore", 14);
			LeaveRule_ignore();
	    }
	 	DebugLocation(92, 1);
		} finally { DebugExitRule(GrammarFileName, "ignore"); }
		return retval;

	}
	// $ANTLR end "ignore"
	#endregion Rules


	#region DFA
	private DFA21 dfa21;
	private DFA24 dfa24;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa21 = new DFA21( this );
		dfa24 = new DFA24( this );
	}

	private class DFA21 : DFA
	{
		private const string DFA21_eotS =
			"\x5\xFFFF";
		private const string DFA21_eofS =
			"\x2\x2\x3\xFFFF";
		private const string DFA21_minS =
			"\x2\x9\x2\xFFFF\x1\xD";
		private const string DFA21_maxS =
			"\x2\x1B\x2\xFFFF\x1\x1B";
		private const string DFA21_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA21_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA21_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x2\x1\x1\x2\x2\x4\xFFFF\x1\x2\x5\xFFFF\x1\x1\x1\x3",
				"\x1\x2\x2\xFFFF\x1\x2\x1\x4\x2\x2\xA\xFFFF\x1\x4\x1\x3",
				"",
				"",
				"\x1\x4\x1\xFFFF\x1\x2\xA\xFFFF\x1\x4\x1\x3"
			};

		private static readonly short[] DFA21_eot = DFA.UnpackEncodedString(DFA21_eotS);
		private static readonly short[] DFA21_eof = DFA.UnpackEncodedString(DFA21_eofS);
		private static readonly char[] DFA21_min = DFA.UnpackEncodedStringToUnsignedChars(DFA21_minS);
		private static readonly char[] DFA21_max = DFA.UnpackEncodedStringToUnsignedChars(DFA21_maxS);
		private static readonly short[] DFA21_accept = DFA.UnpackEncodedString(DFA21_acceptS);
		private static readonly short[] DFA21_special = DFA.UnpackEncodedString(DFA21_specialS);
		private static readonly short[][] DFA21_transition;

		static DFA21()
		{
			int numStates = DFA21_transitionS.Length;
			DFA21_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA21_transition[i] = DFA.UnpackEncodedString(DFA21_transitionS[i]);
			}
		}

		public DFA21( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 21;
			this.eot = DFA21_eot;
			this.eof = DFA21_eof;
			this.min = DFA21_min;
			this.max = DFA21_max;
			this.accept = DFA21_accept;
			this.special = DFA21_special;
			this.transition = DFA21_transition;
		}

		public override string Description { get { return "()* loopback of 77:33: ( ( ignore )* XOR ( ignore )* rhs= andExpr -> ^( XOR $xorExpr $rhs) )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA24 : DFA
	{
		private const string DFA24_eotS =
			"\x5\xFFFF";
		private const string DFA24_eofS =
			"\x2\x2\x3\xFFFF";
		private const string DFA24_minS =
			"\x2\x4\x2\xFFFF\x1\x4";
		private const string DFA24_maxS =
			"\x2\x1B\x2\xFFFF\x1\x1B";
		private const string DFA24_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA24_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA24_transitionS =
			{
				"\x1\x3\x4\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\x1\x2\x2\x4\xFFFF\x1\x2\x5\xFFFF"+
				"\x1\x1\x1\x2",
				"\x1\x3\x4\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\x4\x2\x2\xA\xFFFF\x1\x4\x1"+
				"\x2",
				"",
				"",
				"\x1\x3\x8\xFFFF\x1\x4\x1\xFFFF\x1\x2\xA\xFFFF\x1\x4\x1\x2"
			};

		private static readonly short[] DFA24_eot = DFA.UnpackEncodedString(DFA24_eotS);
		private static readonly short[] DFA24_eof = DFA.UnpackEncodedString(DFA24_eofS);
		private static readonly char[] DFA24_min = DFA.UnpackEncodedStringToUnsignedChars(DFA24_minS);
		private static readonly char[] DFA24_max = DFA.UnpackEncodedStringToUnsignedChars(DFA24_maxS);
		private static readonly short[] DFA24_accept = DFA.UnpackEncodedString(DFA24_acceptS);
		private static readonly short[] DFA24_special = DFA.UnpackEncodedString(DFA24_specialS);
		private static readonly short[][] DFA24_transition;

		static DFA24()
		{
			int numStates = DFA24_transitionS.Length;
			DFA24_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA24_transition[i] = DFA.UnpackEncodedString(DFA24_transitionS[i]);
			}
		}

		public DFA24( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 24;
			this.eot = DFA24_eot;
			this.eof = DFA24_eof;
			this.min = DFA24_min;
			this.max = DFA24_max;
			this.accept = DFA24_accept;
			this.special = DFA24_special;
			this.transition = DFA24_transition;
		}

		public override string Description { get { return "()* loopback of 80:30: ( ( ignore )* AND ( ignore )* rhs= term -> ^( AND $andExpr $rhs) )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declBlock_in_prog120 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _ignore_in_prog124 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _expr_in_prog127 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_CBRACKET_in_declBlock150 = new BitSet(new ulong[]{0x4002200UL});
		public static readonly BitSet _ignore_in_declBlock153 = new BitSet(new ulong[]{0x4082200UL});
		public static readonly BitSet _decl_in_declBlock155 = new BitSet(new ulong[]{0x4082200UL});
		public static readonly BitSet _RIGHT_CBRACKET_in_declBlock159 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_decl178 = new BitSet(new ulong[]{0x4002200UL});
		public static readonly BitSet _ignore_in_decl180 = new BitSet(new ulong[]{0x4002200UL});
		public static readonly BitSet _name_in_decl183 = new BitSet(new ulong[]{0x4003000UL});
		public static readonly BitSet _ignore_in_decl185 = new BitSet(new ulong[]{0x4003000UL});
		public static readonly BitSet _LEFT_PAREN_in_decl188 = new BitSet(new ulong[]{0x4102700UL});
		public static readonly BitSet _ignore_in_decl190 = new BitSet(new ulong[]{0x4102700UL});
		public static readonly BitSet _args_in_decl193 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _RIGHT_PAREN_in_decl196 = new BitSet(new ulong[]{0x24002000UL});
		public static readonly BitSet _ignore_in_decl198 = new BitSet(new ulong[]{0x24002000UL});
		public static readonly BitSet _29_in_decl201 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_type225 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_name246 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arg_in_args265 = new BitSet(new ulong[]{0x14002002UL});
		public static readonly BitSet _ignore_in_args267 = new BitSet(new ulong[]{0x14002002UL});
		public static readonly BitSet _28_in_args272 = new BitSet(new ulong[]{0x4002700UL});
		public static readonly BitSet _ignore_in_args274 = new BitSet(new ulong[]{0x4002700UL});
		public static readonly BitSet _arg_in_args277 = new BitSet(new ulong[]{0x14002002UL});
		public static readonly BitSet _ignore_in_args279 = new BitSet(new ulong[]{0x14002002UL});
		public static readonly BitSet _ID_in_arg302 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_arg315 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_arg328 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _orExpr_in_expr349 = new BitSet(new ulong[]{0x4007202UL});
		public static readonly BitSet _ignore_in_expr351 = new BitSet(new ulong[]{0x5202UL});
		public static readonly BitSet _xorExpr_in_orExpr380 = new BitSet(new ulong[]{0x400A002UL});
		public static readonly BitSet _ignore_in_orExpr390 = new BitSet(new ulong[]{0x400A000UL});
		public static readonly BitSet _OR_in_orExpr393 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _ignore_in_orExpr395 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _xorExpr_in_orExpr400 = new BitSet(new ulong[]{0x400A002UL});
		public static readonly BitSet _andExpr_in_xorExpr428 = new BitSet(new ulong[]{0xC002002UL});
		public static readonly BitSet _ignore_in_xorExpr438 = new BitSet(new ulong[]{0xC002000UL});
		public static readonly BitSet _XOR_in_xorExpr441 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _ignore_in_xorExpr443 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _andExpr_in_xorExpr448 = new BitSet(new ulong[]{0xC002002UL});
		public static readonly BitSet _term_in_andExpr477 = new BitSet(new ulong[]{0x4002012UL});
		public static readonly BitSet _ignore_in_andExpr487 = new BitSet(new ulong[]{0x4002010UL});
		public static readonly BitSet _AND_in_andExpr490 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _ignore_in_andExpr492 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _term_in_andExpr497 = new BitSet(new ulong[]{0x4002012UL});
		public static readonly BitSet _NOT_in_term524 = new BitSet(new ulong[]{0x4003200UL});
		public static readonly BitSet _ignore_in_term526 = new BitSet(new ulong[]{0x4003200UL});
		public static readonly BitSet _atom_in_term529 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_term544 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom559 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEFT_PAREN_in_atom569 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _ignore_in_atom571 = new BitSet(new ulong[]{0x4007200UL});
		public static readonly BitSet _orExpr_in_atom574 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _RIGHT_PAREN_in_atom576 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
